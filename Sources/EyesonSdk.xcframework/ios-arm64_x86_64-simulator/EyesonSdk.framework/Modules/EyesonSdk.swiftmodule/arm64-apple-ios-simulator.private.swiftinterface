// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target arm64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name EyesonSdk
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AVKit
import CommonCrypto
import Dispatch
@_exported import EyesonSdk
import Foundation
import Network
import ReplayKit
import Swift
import UIKit
import VideoToolbox
import WebRTC
import _Concurrency
import _StringProcessing
import zlib
extension EyesonSdk.Socket {
  public func writeFile(_ file: Swift.String.File) throws
}
extension EyesonSdk.Eyeson {
  public enum Device {
    case audio
    case video
    case remoteAudio
    public static func == (a: EyesonSdk.Eyeson.Device, b: EyesonSdk.Eyeson.Device) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Event {
  }
  public enum TerminateReason : Swift.Int {
    case unwanted
    case busy
    case declined
    case terminated
    case gone
    case locked
    case other
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
public protocol EyesonEvent {
}
extension EyesonSdk.Eyeson.Event {
  public struct Setup : EyesonSdk.EyesonEvent {
    public var locked: Swift.Bool
    public var recording: EyesonSdk.Eyeson.Event.Recording?
    public var snapshots: [EyesonSdk.Eyeson.Event.Snapshots.Item]?
    public var broadcasts: [EyesonSdk.Eyeson.Event.Broadcasts.Item]?
  }
  public struct Mode : EyesonSdk.EyesonEvent {
    public var video: Swift.Bool
    public var p2p: Swift.Bool
  }
  public struct Chat : EyesonSdk.EyesonEvent, Swift.Identifiable {
    public var id: Swift.String
    public var timestamp: Foundation.Date
    public var user: EyesonSdk.Eyeson.User
    public var message: Swift.String
    public typealias ID = Swift.String
  }
  public struct Custom : Swift.Codable, EyesonSdk.EyesonEvent {
    public var content: Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Locked : Swift.Codable, EyesonSdk.EyesonEvent {
    public var locked: Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Participants : EyesonSdk.EyesonEvent {
    public var audio: [EyesonSdk.Eyeson.User]
    public var video: [EyesonSdk.Eyeson.User]
    public var presenter: EyesonSdk.Eyeson.User?
  }
  public struct Recording : Swift.Codable, Swift.Identifiable, EyesonSdk.EyesonEvent {
    public var id: Swift.String
    public var duration: Swift.Double?
    public var links: EyesonSdk.Eyeson.Event.Recording.Links
    public var user: EyesonSdk.Eyeson.User
    public var createdAt: Foundation.Date
    public struct Links : Swift.Codable {
      public var download: Foundation.URL?
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public typealias ID = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Voice : EyesonSdk.EyesonEvent {
    public var user: EyesonSdk.Eyeson.User
    public var active: Swift.Bool
  }
  public struct Muted : Swift.Codable, EyesonSdk.EyesonEvent {
    public var by: EyesonSdk.Eyeson.User
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Snapshots : Swift.Codable, EyesonSdk.EyesonEvent {
    public var items: [EyesonSdk.Eyeson.Event.Snapshots.Item]
    public struct Item : Swift.Codable, Swift.Identifiable {
      public var id: Swift.String
      public var name: Swift.String
      public var links: EyesonSdk.Eyeson.Event.Snapshots.Item.Links
      public var user: EyesonSdk.Eyeson.User
      public var createdAt: Foundation.Date
      public struct Links : Swift.Codable {
        public var download: Foundation.URL
        public func encode(to encoder: any Swift.Encoder) throws
        public init(from decoder: any Swift.Decoder) throws
      }
      public typealias ID = Swift.String
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Broadcasts : Swift.Codable, EyesonSdk.EyesonEvent {
    public var items: [EyesonSdk.Eyeson.Event.Broadcasts.Item]
    public struct Item : Swift.Codable, Swift.Identifiable {
      public var id: Swift.String
      public var platform: Swift.String
      public var playerUrl: Foundation.URL
      public var user: EyesonSdk.Eyeson.User
      public typealias ID = Swift.String
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Playback : Swift.Codable, EyesonSdk.EyesonEvent {
    public var items: [EyesonSdk.Eyeson.Event.Playback.Item]
    public struct Item : Swift.Codable, Swift.Identifiable {
      public var id: Swift.String
      public var name: Swift.String
      public var url: Foundation.URL
      public var replacementId: Swift.String
      public var audio: Swift.Bool
      public typealias ID = Swift.String
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Terminated : EyesonSdk.EyesonEvent {
    public var reason: EyesonSdk.Eyeson.TerminateReason
  }
  public struct Stats : EyesonSdk.EyesonEvent {
    public var jitter: Swift.Double
    public var packetLoss: Swift.Double
    public var roundTripTime: Swift.Double
    public var nack: Swift.Double
    public var bitrateSend: Swift.Double
    public var bitrateReceive: Swift.Double
    public var status: EyesonSdk.Eyeson.Event.Stats.Status
    public var bytesSent: Swift.Double
    public var bytesReceived: Swift.Double
    public var time: Foundation.TimeInterval
    public enum Status : Swift.String {
      case bad
      case ok
      case good
      case unknown
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
  }
}
public enum SwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension EyesonSdk.SwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct JSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  public mutating func merge(with other: EyesonSdk.JSON) throws
  public func merged(with other: EyesonSdk.JSON) throws -> EyesonSdk.JSON
  public var type: EyesonSdk.`Type` {
    get
  }
  public var error: EyesonSdk.SwiftyJSONError? {
    get
  }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: EyesonSdk.JSON {
    get
  }
  public static var null: EyesonSdk.JSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: EyesonSdk.Index<T>, rhs: EyesonSdk.Index<T>) -> Swift.Bool
  public static func < (lhs: EyesonSdk.Index<T>, rhs: EyesonSdk.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = EyesonSdk.Index<EyesonSdk.JSON>
public typealias JSONRawIndex = EyesonSdk.Index<Any>
extension EyesonSdk.JSON : Swift.Collection {
  public typealias Index = EyesonSdk.JSONRawIndex
  public var startIndex: EyesonSdk.JSON.Index {
    get
  }
  public var endIndex: EyesonSdk.JSON.Index {
    get
  }
  public func index(after i: EyesonSdk.JSON.Index) -> EyesonSdk.JSON.Index
  public subscript(position: EyesonSdk.JSON.Index) -> (Swift.String, EyesonSdk.JSON) {
    get
  }
  public typealias Element = (Swift.String, EyesonSdk.JSON)
  public typealias Indices = Swift.DefaultIndices<EyesonSdk.JSON>
  public typealias Iterator = Swift.IndexingIterator<EyesonSdk.JSON>
  public typealias SubSequence = Swift.Slice<EyesonSdk.JSON>
}
public enum JSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: EyesonSdk.JSONKey { get }
}
extension Swift.Int : EyesonSdk.JSONSubscriptType {
  public var jsonKey: EyesonSdk.JSONKey {
    get
  }
}
extension Swift.String : EyesonSdk.JSONSubscriptType {
  public var jsonKey: EyesonSdk.JSONKey {
    get
  }
}
extension EyesonSdk.JSON {
  public subscript(path: [any EyesonSdk.JSONSubscriptType]) -> EyesonSdk.JSON {
    get
    set
  }
  public subscript(path: any EyesonSdk.JSONSubscriptType...) -> EyesonSdk.JSON {
    get
    set
  }
}
extension EyesonSdk.JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension EyesonSdk.JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension EyesonSdk.JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension EyesonSdk.JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension EyesonSdk.JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension EyesonSdk.JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension EyesonSdk.JSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [EyesonSdk.writingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension EyesonSdk.JSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension EyesonSdk.JSON {
  public var array: [EyesonSdk.JSON]? {
    get
  }
  public var arrayValue: [EyesonSdk.JSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension EyesonSdk.JSON {
  public var dictionary: [Swift.String : EyesonSdk.JSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : EyesonSdk.JSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension EyesonSdk.JSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension EyesonSdk.JSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension EyesonSdk.JSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension EyesonSdk.JSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension EyesonSdk.JSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension EyesonSdk.JSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension EyesonSdk.JSON : Swift.Comparable {
}
public func == (lhs: EyesonSdk.JSON, rhs: EyesonSdk.JSON) -> Swift.Bool
public func <= (lhs: EyesonSdk.JSON, rhs: EyesonSdk.JSON) -> Swift.Bool
public func >= (lhs: EyesonSdk.JSON, rhs: EyesonSdk.JSON) -> Swift.Bool
public func > (lhs: EyesonSdk.JSON, rhs: EyesonSdk.JSON) -> Swift.Bool
public func < (lhs: EyesonSdk.JSON, rhs: EyesonSdk.JSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: EyesonSdk.writingOptionsKeys, b: EyesonSdk.writingOptionsKeys) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension EyesonSdk.JSON : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public class HttpRequest {
  public var path: Swift.String
  public var queryParams: [(Swift.String, Swift.String)]
  public var method: Swift.String
  public var headers: [Swift.String : Swift.String]
  public var body: [Swift.UInt8]
  public var address: Swift.String?
  public var params: [Swift.String : Swift.String]
  public init()
  public func hasTokenForHeader(_ headerName: Swift.String, token: Swift.String) -> Swift.Bool
  public func parseUrlencodedForm() -> [(Swift.String, Swift.String)]
  public struct MultiPart {
    public let headers: [Swift.String : Swift.String]
    public let body: [Swift.UInt8]
    public var name: Swift.String? {
      get
    }
    public var fileName: Swift.String? {
      get
    }
  }
  public func parseMultiPartFormData() -> [EyesonSdk.HttpRequest.MultiPart]
  @objc deinit
}
extension Swift.String {
  public enum FileError : Swift.Error {
    case error(Swift.Int32)
  }
  public class File {
    public init(_ pointer: Swift.UnsafeMutablePointer<Darwin.FILE>)
    public func close()
    public func seek(_ offset: Swift.Int) -> Swift.Bool
    public func read(_ data: inout [Swift.UInt8]) throws -> Swift.Int
    public func write(_ data: [Swift.UInt8]) throws
    public static func currentWorkingDirectory() throws -> Swift.String
    @objc deinit
  }
  public static var pathSeparator: Swift.String
  public func openNewForWriting() throws -> Swift.String.File
  public func openForReading() throws -> Swift.String.File
  public func openForWritingAndReading() throws -> Swift.String.File
  public func openFileForMode(_ path: Swift.String, _ mode: Swift.String) throws -> Swift.String.File
  public func exists() throws -> Swift.Bool
  public func directory() throws -> Swift.Bool
  public func files() throws -> [Swift.String]
}
public protocol HttpServerIODelegate : AnyObject {
  func socketConnectionReceived(_ socket: EyesonSdk.Socket)
}
@_hasMissingDesignatedInitializers open class HttpServerIO {
  weak public var delegate: (any EyesonSdk.HttpServerIODelegate)?
  public enum HttpServerIOState : Swift.Int32 {
    case starting
    case running
    case stopping
    case stopped
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
  public var state: EyesonSdk.HttpServerIO.HttpServerIOState {
    get
  }
  public var operating: Swift.Bool {
    get
  }
  public var listenAddressIPv4: Swift.String?
  public var listenAddressIPv6: Swift.String?
  public func port() throws -> Swift.Int
  public func isIPv4() throws -> Swift.Bool
  @objc deinit
  @available(macOS 10.10, *)
  public func start(_ port: Darwin.in_port_t = 8080, forceIPv4: Swift.Bool = false, priority: Dispatch.DispatchQoS.QoSClass = DispatchQoS.QoSClass.background) throws
  public func stop()
  open func dispatch(_ request: EyesonSdk.HttpRequest) -> ([Swift.String : Swift.String], (EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)
}
extension EyesonSdk.WebSocketClient {
  public func subscribe(to token: Swift.String)
  public func unsubscribe(from token: Swift.String)
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NativeEngine : ObjectiveC.NSObject, EyesonSdk.Engine, Foundation.URLSessionDataDelegate, Foundation.URLSessionWebSocketDelegate {
  public func register(delegate: any EyesonSdk.EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: EyesonSdk.FrameOpCode, completion: (() -> ())?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didOpenWithProtocol protocol: Swift.String?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didCloseWith closeCode: Foundation.URLSessionWebSocketTask.CloseCode, reason: Foundation.Data?)
  @objc override dynamic public init()
  @objc deinit
}
public enum Environment : Swift.String {
  case development
  case staging
  case production
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ConnectionEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(any Swift.Error)
}
public protocol Connection {
  func write(data: Foundation.Data, opcode: EyesonSdk.FrameOpCode)
}
public protocol ConnectionDelegate : AnyObject {
  func didReceive(event: EyesonSdk.ServerEvent)
}
public enum ServerEvent {
  case connected(any EyesonSdk.Connection, [Swift.String : Swift.String])
  case disconnected(any EyesonSdk.Connection, Swift.String, Swift.UInt16)
  case text(any EyesonSdk.Connection, Swift.String)
  case binary(any EyesonSdk.Connection, Foundation.Data)
  case pong(any EyesonSdk.Connection, Foundation.Data?)
  case ping(any EyesonSdk.Connection, Foundation.Data?)
}
public protocol Server {
  func start(address: Swift.String, port: Swift.UInt16) -> (any Swift.Error)?
}
@_hasMissingDesignatedInitializers public class Process {
  public static var pid: Swift.Int {
    get
  }
  public static var tid: Swift.UInt64 {
    get
  }
  public static func watchSignals(_ callback: @escaping (Swift.Int32) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Errno {
  public class func description() -> Swift.String
  @objc deinit
}
public enum SocketError : Swift.Error {
  case socketCreationFailed(Swift.String)
  case socketSettingReUseAddrFailed(Swift.String)
  case bindFailed(Swift.String)
  case listenFailed(Swift.String)
  case writeFailed(Swift.String)
  case getPeerNameFailed(Swift.String)
  case convertingPeerNameFailed
  case getNameInfoFailed(Swift.String)
  case acceptFailed(Swift.String)
  case recvFailed(Swift.String)
  case getSockNameFailed(Swift.String)
}
open class Socket : Swift.Hashable, Swift.Equatable {
  public init(socketFileDescriptor: Swift.Int32)
  @objc deinit
  public func hash(into hasher: inout Swift.Hasher)
  public func close()
  public func port() throws -> Darwin.in_port_t
  public func isIPv4() throws -> Swift.Bool
  public func writeUTF8(_ string: Swift.String) throws
  public func writeUInt8(_ data: [Swift.UInt8]) throws
  public func writeUInt8(_ data: Swift.ArraySlice<Swift.UInt8>) throws
  public func writeData(_ data: Foundation.NSData) throws
  public func writeData(_ data: Foundation.Data) throws
  open func read() throws -> Swift.UInt8
  open func read(length: Swift.Int) throws -> [Swift.UInt8]
  public func readLine() throws -> Swift.String
  public func peername() throws -> Swift.String
  public class func setNoSigPipe(_ socket: Swift.Int32)
  public class func close(_ socket: Swift.Int32)
  open var hashValue: Swift.Int {
    get
  }
}
public func == (socket1: EyesonSdk.Socket, socket2: EyesonSdk.Socket) -> Swift.Bool
public func demoServer(_ publicDir: Swift.String) -> EyesonSdk.HttpServer
public func shareFile(_ path: Swift.String) -> ((EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)
public func shareFilesFromDirectory(_ directoryPath: Swift.String, defaults: [Swift.String] = ["index.html", "default.html"]) -> ((EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)
public func directoryBrowser(_ dir: Swift.String) -> ((EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum FrameOpCode : Swift.UInt8 {
  case continueFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct Frame {
}
public enum FrameEvent {
  case frame(EyesonSdk.Frame)
  case error(any Swift.Error)
}
public protocol FramerEventClient : AnyObject {
  func frameProcessed(event: EyesonSdk.FrameEvent)
}
public protocol Framer {
  func add(data: Foundation.Data)
  func register(delegate: any EyesonSdk.FramerEventClient)
  func createWriteFrame(opcode: EyesonSdk.FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  func updateCompression(supports: Swift.Bool)
  func supportsCompression() -> Swift.Bool
}
public class WSFramer : EyesonSdk.Framer {
  public var compressionEnabled: Swift.Bool
  public init(isServer: Swift.Bool = false)
  public func updateCompression(supports: Swift.Bool)
  public func supportsCompression() -> Swift.Bool
  public func add(data: Foundation.Data)
  public func register(delegate: any EyesonSdk.FramerEventClient)
  public func createWriteFrame(opcode: EyesonSdk.FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  @objc deinit
}
public protocol MyWSArrayType {
}
extension Swift.UInt8 : EyesonSdk.MyWSArrayType {
}
extension Swift.Array where Element : EyesonSdk.MyWSArrayType, Element : Swift.UnsignedInteger {
  public func readUint16(offset: Swift.Int) -> Swift.UInt16
  public func readUint64(offset: Swift.Int) -> Swift.UInt64
  public func unmaskData(maskStart: Swift.Int, offset: Swift.Int, length: Swift.Int) -> Foundation.Data
}
public func writeUint16(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt16)
public func writeUint32(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt32)
public func writeUint64(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt64)
public enum ErrorType : Swift.Error {
  case compressionError
  case securityError
  case protocolError
  case serverError
  public static func == (a: EyesonSdk.ErrorType, b: EyesonSdk.ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: EyesonSdk.ErrorType
  public let message: Swift.String
  public let code: Swift.UInt16
  public init(type: EyesonSdk.ErrorType, message: Swift.String, code: Swift.UInt16)
}
public protocol WebSocketClient : AnyObject {
  func connect()
  func disconnect(closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(stringData: Foundation.Data, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension EyesonSdk.WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public enum WebSocketEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error((any Swift.Error)?)
  case viabilityChanged(Swift.Bool)
  case reconnectSuggested(Swift.Bool)
  case cancelled
}
public protocol WebSocketDelegate : AnyObject {
  func didReceive(event: EyesonSdk.WebSocketEvent, client: EyesonSdk.WebSocket)
}
open class WebSocket : EyesonSdk.WebSocketClient, EyesonSdk.EngineDelegate {
  weak public var delegate: (any EyesonSdk.WebSocketDelegate)?
  public var onEvent: ((EyesonSdk.WebSocketEvent) -> Swift.Void)?
  public var request: Foundation.URLRequest
  public var callbackQueue: Dispatch.DispatchQueue
  public var respondToPingWithPong: Swift.Bool {
    get
    set
  }
  public init(request: Foundation.URLRequest, engine: any EyesonSdk.Engine)
  convenience public init(request: Foundation.URLRequest, certPinner: (any EyesonSdk.CertificatePinning)? = FoundationSecurity(), compressionHandler: (any EyesonSdk.CompressionHandler)? = nil, useCustomEngine: Swift.Bool = true)
  public func connect()
  public func disconnect(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceDisconnect()
  public func write(data: Foundation.Data, completion: (() -> ())?)
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(stringData: Foundation.Data, completion: (() -> ())?)
  public func write(ping: Foundation.Data, completion: (() -> ())?)
  public func write(pong: Foundation.Data, completion: (() -> ())?)
  public func didReceive(event: EyesonSdk.WebSocketEvent)
  @objc deinit
}
public class FoundationHTTPHandler : EyesonSdk.HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: any EyesonSdk.HTTPHandlerDelegate)
  @objc deinit
}
@available(*, deprecated, message: "Use websocket(text:binary:pong:connected:disconnected:) instead.")
public func websocket(_ text: @escaping (EyesonSdk.WebSocketSession, Swift.String) -> Swift.Void, _ binary: @escaping (EyesonSdk.WebSocketSession, [Swift.UInt8]) -> Swift.Void, _ pong: @escaping (EyesonSdk.WebSocketSession, [Swift.UInt8]) -> Swift.Void) -> ((EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)
public func websocket(text: ((EyesonSdk.WebSocketSession, Swift.String) -> Swift.Void)? = nil, binary: ((EyesonSdk.WebSocketSession, [Swift.UInt8]) -> Swift.Void)? = nil, pong: ((EyesonSdk.WebSocketSession, [Swift.UInt8]) -> Swift.Void)? = nil, connected: ((EyesonSdk.WebSocketSession) -> Swift.Void)? = nil, disconnected: ((EyesonSdk.WebSocketSession) -> Swift.Void)? = nil) -> ((EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)
public class WebSocketSession : Swift.Hashable, Swift.Equatable {
  public enum WsError : Swift.Error {
    case unknownOpCode(Swift.String), unMaskedFrame(Swift.String), protocolError(Swift.String), invalidUTF8(Swift.String)
  }
  public enum OpCode : Swift.UInt8 {
    case `continue`, close, ping, pong, text, binary
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum Control : Swift.Error {
    case close
    public static func == (a: EyesonSdk.WebSocketSession.Control, b: EyesonSdk.WebSocketSession.Control) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers public class Frame {
    public var opcode: EyesonSdk.WebSocketSession.OpCode
    public var fin: Swift.Bool
    public var rsv1: Swift.UInt8
    public var rsv2: Swift.UInt8
    public var rsv3: Swift.UInt8
    public var payload: [Swift.UInt8]
    @objc deinit
  }
  final public let socket: EyesonSdk.Socket
  public init(_ socket: EyesonSdk.Socket)
  @objc deinit
  public func writeText(_ text: Swift.String)
  public func writeBinary(_ binary: [Swift.UInt8])
  public func writeBinary(_ binary: Swift.ArraySlice<Swift.UInt8>)
  public func writeFrame(_ data: Swift.ArraySlice<Swift.UInt8>, _ op: EyesonSdk.WebSocketSession.OpCode, _ fin: Swift.Bool = true)
  public func writeCloseFrame()
  public func readFrame() throws -> EyesonSdk.WebSocketSession.Frame
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func == (webSocketSession1: EyesonSdk.WebSocketSession, webSocketSession2: EyesonSdk.WebSocketSession) -> Swift.Bool
extension Swift.String {
  public func unquote() -> Swift.String
}
extension Swift.Unicode.Scalar {
  public func asWhitespace() -> Swift.UInt8?
}
extension EyesonSdk.Eyeson {
  public struct Links : Swift.Codable {
    public var guestLink: Foundation.URL
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
public protocol CompressionHandler {
  func load(headers: [Swift.String : Swift.String])
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  func compress(data: Foundation.Data) -> Foundation.Data?
}
public protocol EyesonScreencastService {
  func observe(onUpdate: ((Swift.Bool) -> ())?)
}
public protocol EyesonSDK {
  var environment: EyesonSdk.Environment { get set }
  func join(_ accessKey: Swift.String, completion: @escaping ((any EyesonSdk.EyesonMeeting)?, EyesonSdk.Eyeson.Event.Terminated?) -> Swift.Void)
  func join(_ accessKey: Swift.String, video: Swift.Bool, camera: AVFoundation.AVCaptureDevice.Position, videoMuted: Swift.Bool, audioMuted: Swift.Bool, completion: @escaping ((any EyesonSdk.EyesonMeeting)?, EyesonSdk.Eyeson.Event.Terminated?) -> Swift.Void)
  func join(_ guestToken: Swift.String, name: Swift.String, completion: @escaping ((any EyesonSdk.EyesonMeeting)?, EyesonSdk.Eyeson.Event.Terminated?) -> Swift.Void)
  func join(_ guestToken: Swift.String, name: Swift.String, video: Swift.Bool, camera: AVFoundation.AVCaptureDevice.Position, videoMuted: Swift.Bool, audioMuted: Swift.Bool, completion: @escaping ((any EyesonSdk.EyesonMeeting)?, EyesonSdk.Eyeson.Event.Terminated?) -> Swift.Void)
}
public protocol EyesonDelegate {
  func eyeson(_ meeting: any EyesonSdk.EyesonMeeting, didReceive event: any EyesonSdk.EyesonEvent)
}
public protocol EyesonMeeting {
  var delegate: (any EyesonSdk.EyesonDelegate)? { get set }
  var links: EyesonSdk.Eyeson.Links { get }
  var localVideoView: UIKit.UIView { get }
  var remoteVideoView: UIKit.UIView { get }
  var camera: AVFoundation.AVCaptureDevice.Position { get set }
  var user: EyesonSdk.Eyeson.User { get }
  var screencast: any EyesonSdk.EyesonScreencastService { get }
  func user(_ id: Swift.String, completion: @escaping (EyesonSdk.Eyeson.User?, (any Swift.Error)?) -> Swift.Void)
  func mute(_ device: EyesonSdk.Eyeson.Device, _ mute: Swift.Bool)
  func muteAll()
  func send(chat message: Swift.String)
  func send(custom content: Swift.String)
  func startRecording()
  func stopRecording()
  func startPlayback(id: Swift.String, audio: Swift.Bool, replace userId: Swift.String, url: Foundation.URL, name: Swift.String, loopCount: Swift.Int)
  func stopPlayback(id: Swift.String)
  func startBroadcast(streamUrl: Foundation.URL, playerUrl: Foundation.URL)
  func updateBroadcast(playerUrl: Foundation.URL)
  func stopBroadcast()
  func snapshot()
  func setLayout(_ layout: Swift.String)
  func setPresenter(_ isActive: Swift.Bool)
  func addLayer(image: UIKit.UIImage, index: Swift.Int?)
  func addLayer(url: Foundation.URL, index: Swift.Int?)
  func addLayer(icon: Swift.String?, title: Swift.String?, content: Swift.String?, index: Swift.Int?)
  func removeLayer(index: Swift.Int)
  func kick(user id: Swift.String)
  func lock()
  func leave()
  func stats(completion: @escaping (EyesonSdk.Eyeson.Event.Stats) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class Eyeson : EyesonSdk.EyesonSDK {
  public static var shared: any EyesonSdk.EyesonSDK
  public var environment: EyesonSdk.Environment {
    get
    set
  }
  public func join(_ accessKey: Swift.String, completion: @escaping ((any EyesonSdk.EyesonMeeting)?, EyesonSdk.Eyeson.Event.Terminated?) -> Swift.Void)
  public func join(_ guestToken: Swift.String, name: Swift.String, completion: @escaping ((any EyesonSdk.EyesonMeeting)?, EyesonSdk.Eyeson.Event.Terminated?) -> Swift.Void)
  public func join(_ accessKey: Swift.String, video: Swift.Bool, camera: AVFoundation.AVCaptureDevice.Position, videoMuted: Swift.Bool, audioMuted: Swift.Bool, completion: @escaping ((any EyesonSdk.EyesonMeeting)?, EyesonSdk.Eyeson.Event.Terminated?) -> Swift.Void)
  public func join(_ guestToken: Swift.String, name: Swift.String, video: Swift.Bool, camera: AVFoundation.AVCaptureDevice.Position, videoMuted: Swift.Bool, audioMuted: Swift.Bool, completion: @escaping ((any EyesonSdk.EyesonMeeting)?, EyesonSdk.Eyeson.Event.Terminated?) -> Swift.Void)
  @objc deinit
}
extension EyesonSdk.Eyeson {
  public struct User : Swift.Codable {
    public var id: Swift.String
    public var name: Swift.String
    public var avatar: Foundation.URL?
    public var guest: Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
public enum FoundationSecurityError : Swift.Error {
  case invalidRequest
  public static func == (a: EyesonSdk.FoundationSecurityError, b: EyesonSdk.FoundationSecurityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class FoundationSecurity {
  public init(allowSelfSigned: Swift.Bool = false)
  @objc deinit
}
extension EyesonSdk.FoundationSecurity : EyesonSdk.CertificatePinning {
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((EyesonSdk.PinningState) -> ()))
}
extension EyesonSdk.FoundationSecurity : EyesonSdk.HeaderValidator {
  public func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> (any Swift.Error)?
}
public protocol FrameCollectorDelegate : AnyObject {
  func didForm(event: EyesonSdk.FrameCollector.Event)
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
}
@_hasMissingDesignatedInitializers public class FrameCollector {
  public enum Event {
    case text(Swift.String)
    case binary(Foundation.Data)
    case pong(Foundation.Data?)
    case ping(Foundation.Data?)
    case error(any Swift.Error)
    case closed(Swift.String, Swift.UInt16)
  }
  public func add(frame: EyesonSdk.Frame)
  @objc deinit
}
public enum ConnectionState {
  case connected
  case waiting
  case cancelled
  case failed((any Swift.Error)?)
  case viability(Swift.Bool)
  case shouldReconnect(Swift.Bool)
  case receive(Foundation.Data)
}
public protocol TransportEventClient : AnyObject {
  func connectionChanged(state: EyesonSdk.ConnectionState)
}
public protocol Transport : AnyObject {
  func register(delegate: any EyesonSdk.TransportEventClient)
  func connect(url: Foundation.URL, timeout: Swift.Double, certificatePinning: (any EyesonSdk.CertificatePinning)?)
  func disconnect()
  func write(data: Foundation.Data, completion: @escaping (((any Swift.Error)?) -> ()))
  var usingTLS: Swift.Bool { get }
}
public enum SerializationError : Swift.Error {
  case invalidObject
  case notSupported
  public static func == (a: EyesonSdk.SerializationError, b: EyesonSdk.SerializationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol HttpResponseBodyWriter {
  func write(_ file: Swift.String.File) throws
  func write(_ data: [Swift.UInt8]) throws
  func write(_ data: Swift.ArraySlice<Swift.UInt8>) throws
  func write(_ data: Foundation.NSData) throws
  func write(_ data: Foundation.Data) throws
}
public enum HttpResponseBody {
  case json(Any)
  case html(Swift.String)
  case htmlBody(Swift.String)
  case text(Swift.String)
  case data(Foundation.Data, contentType: Swift.String? = nil)
  case custom(Any, (Any) throws -> Swift.String)
}
public enum HttpResponse {
  case switchProtocols([Swift.String : Swift.String], (EyesonSdk.Socket) -> Swift.Void)
  case ok(EyesonSdk.HttpResponseBody, _: [Swift.String : Swift.String] = [:]), created, accepted
  case movedPermanently(Swift.String)
  case movedTemporarily(Swift.String)
  case badRequest(EyesonSdk.HttpResponseBody?), unauthorized(EyesonSdk.HttpResponseBody?), forbidden(EyesonSdk.HttpResponseBody?), notFound(_: EyesonSdk.HttpResponseBody? = nil), notAcceptable(EyesonSdk.HttpResponseBody?), tooManyRequests(EyesonSdk.HttpResponseBody?), internalServerError(EyesonSdk.HttpResponseBody?)
  case raw(Swift.Int, Swift.String, [Swift.String : Swift.String]?, ((any EyesonSdk.HttpResponseBodyWriter) throws -> Swift.Void)?)
  public var statusCode: Swift.Int {
    get
  }
  public var reasonPhrase: Swift.String {
    get
  }
  public func headers() -> [Swift.String : Swift.String]
}
public class WSCompression : EyesonSdk.CompressionHandler {
  public init()
  public func load(headers: [Swift.String : Swift.String])
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func compress(data: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
public enum SecurityErrorCode : Swift.UInt16 {
  case acceptFailed
  case pinningFailed
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum PinningState {
  case success
  case failed(CoreFoundation.CFError?)
}
public protocol CertificatePinning : AnyObject {
  func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((EyesonSdk.PinningState) -> ()))
}
public protocol HeaderValidator : AnyObject {
  func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> (any Swift.Error)?
}
public enum FoundationTransportError : Swift.Error {
  case invalidRequest
  case invalidOutputStream
  case timeout
  public static func == (a: EyesonSdk.FoundationTransportError, b: EyesonSdk.FoundationTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public class FoundationTransport : ObjectiveC.NSObject, EyesonSdk.Transport, Foundation.StreamDelegate {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(streamConfiguration: ((Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? = nil)
  @objc deinit
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: (any EyesonSdk.CertificatePinning)? = nil)
  public func disconnect()
  public func register(delegate: any EyesonSdk.TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping (((any Swift.Error)?) -> ()))
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
}
public class StringHTTPHandler : EyesonSdk.HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: any EyesonSdk.HTTPHandlerDelegate)
  @objc deinit
}
public enum HTTPUpgradeError : Swift.Error {
  case notAnUpgrade(Swift.Int)
  case invalidData
}
public struct HTTPWSHeader {
  public static func createUpgrade(request: Foundation.URLRequest, supportsCompression: Swift.Bool, secKeyValue: Swift.String) -> Foundation.URLRequest
  public static func generateWebSocketKey() -> Swift.String
}
public enum HTTPEvent {
  case success([Swift.String : Swift.String])
  case failure(any Swift.Error)
}
public protocol HTTPHandlerDelegate : AnyObject {
  func didReceiveHTTP(event: EyesonSdk.HTTPEvent)
}
public protocol HTTPHandler {
  func register(delegate: any EyesonSdk.HTTPHandlerDelegate)
  func convert(request: Foundation.URLRequest) -> Foundation.Data
  func parse(data: Foundation.Data) -> Swift.Int
}
public protocol HTTPServerDelegate : AnyObject {
  func didReceive(event: EyesonSdk.HTTPEvent)
}
public protocol HTTPServerHandler {
  func register(delegate: any EyesonSdk.HTTPServerDelegate)
  func parse(data: Foundation.Data)
  func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
}
public struct URLParts {
}
extension Foundation.URL {
  public var isTLSScheme: Swift.Bool {
    get
  }
  public func getParts() -> EyesonSdk.URLParts?
}
extension EyesonSdk.Socket {
  public class func tcpSocketForListen(_ port: Darwin.in_port_t, _ forceIPv4: Swift.Bool = false, _ maxPendingConnection: Swift.Int32 = SOMAXCONN, _ listenAddress: Swift.String? = nil) throws -> EyesonSdk.Socket
  public func acceptClientSocket() throws -> EyesonSdk.Socket
}
public class WSEngine : EyesonSdk.Engine, EyesonSdk.TransportEventClient, EyesonSdk.FramerEventClient, EyesonSdk.FrameCollectorDelegate, EyesonSdk.HTTPHandlerDelegate {
  public var respondToPingWithPong: Swift.Bool
  public init(transport: any EyesonSdk.Transport, certPinner: (any EyesonSdk.CertificatePinning)? = nil, headerValidator: any EyesonSdk.HeaderValidator = FoundationSecurity(), httpHandler: any EyesonSdk.HTTPHandler = FoundationHTTPHandler(), framer: any EyesonSdk.Framer = WSFramer(), compressionHandler: (any EyesonSdk.CompressionHandler)? = nil)
  public func register(delegate: any EyesonSdk.EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: EyesonSdk.FrameOpCode, completion: (() -> ())?)
  public func connectionChanged(state: EyesonSdk.ConnectionState)
  public func didReceiveHTTP(event: EyesonSdk.HTTPEvent)
  public func frameProcessed(event: EyesonSdk.FrameEvent)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func didForm(event: EyesonSdk.FrameCollector.Event)
  @objc deinit
}
public enum TCPTransportError : Swift.Error {
  case invalidRequest
  public static func == (a: EyesonSdk.TCPTransportError, b: EyesonSdk.TCPTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class TCPTransport : EyesonSdk.Transport {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(connection: Network.NWConnection)
  public init()
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: (any EyesonSdk.CertificatePinning)? = nil)
  public func disconnect()
  public func register(delegate: any EyesonSdk.TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping (((any Swift.Error)?) -> ()))
  @objc deinit
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@available(watchOS, unavailable)
public class WebSocketServer : EyesonSdk.Server, EyesonSdk.ConnectionDelegate {
  public var onEvent: ((EyesonSdk.ServerEvent) -> Swift.Void)?
  public init()
  public func start(address: Swift.String, port: Swift.UInt16) -> (any Swift.Error)?
  public func didReceive(event: EyesonSdk.ServerEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class ServerConnection : EyesonSdk.Connection, EyesonSdk.HTTPServerDelegate, EyesonSdk.FramerEventClient, EyesonSdk.FrameCollectorDelegate, EyesonSdk.TransportEventClient {
  public var onEvent: ((EyesonSdk.ConnectionEvent) -> Swift.Void)?
  weak public var delegate: (any EyesonSdk.ConnectionDelegate)?
  public func write(data: Foundation.Data, opcode: EyesonSdk.FrameOpCode)
  public func connectionChanged(state: EyesonSdk.ConnectionState)
  public func didReceive(event: EyesonSdk.HTTPEvent)
  public func frameProcessed(event: EyesonSdk.FrameEvent)
  public func didForm(event: EyesonSdk.FrameCollector.Event)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  @objc deinit
}
public protocol EngineDelegate : AnyObject {
  func didReceive(event: EyesonSdk.WebSocketEvent)
}
public protocol Engine {
  func register(delegate: any EyesonSdk.EngineDelegate)
  func start(request: Foundation.URLRequest)
  func stop(closeCode: Swift.UInt16)
  func forceStop()
  func write(data: Foundation.Data, opcode: EyesonSdk.FrameOpCode, completion: (() -> ())?)
  func write(string: Swift.String, completion: (() -> ())?)
}
open class HttpRouter {
  public init()
  public func routes() -> [Swift.String]
  public func register(_ method: Swift.String?, path: Swift.String, handler: ((EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)?)
  public func route(_ method: Swift.String?, path: Swift.String) -> ([Swift.String : Swift.String], (EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)?
  @objc deinit
}
extension Foundation.NSURL {
  public func mimeType() -> Swift.String
}
extension Foundation.NSString {
  public func mimeType() -> Swift.String
}
extension Swift.String {
  public func mimeType() -> Swift.String
}
public class HttpParser {
  public init()
  public func readHttpRequest(_ socket: EyesonSdk.Socket) throws -> EyesonSdk.HttpRequest
  @objc deinit
}
extension Swift.String {
  public static func toBase64(_ data: [Swift.UInt8]) -> Swift.String
}
@_hasMissingDesignatedInitializers public class FoundationHTTPServerHandler : EyesonSdk.HTTPServerHandler {
  public func register(delegate: any EyesonSdk.HTTPServerDelegate)
  public func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
  public func parse(data: Foundation.Data)
  @objc deinit
}
public func scopes(_ scope: @escaping EyesonSdk.Closure) -> ((EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)
public typealias Closure = () -> Swift.Void
public var idd: Swift.String?
public var dir: Swift.String?
public var rel: Swift.String?
public var rev: Swift.String?
public var alt: Swift.String?
public var forr: Swift.String?
public var src: Swift.String?
public var type: Swift.String?
public var href: Swift.String?
public var text: Swift.String?
public var abbr: Swift.String?
public var size: Swift.String?
public var face: Swift.String?
public var char: Swift.String?
public var cite: Swift.String?
public var span: Swift.String?
public var data: Swift.String?
public var axis: Swift.String?
public var Name: Swift.String?
public var name: Swift.String?
public var code: Swift.String?
public var link: Swift.String?
public var lang: Swift.String?
public var cols: Swift.String?
public var rows: Swift.String?
public var ismap: Swift.String?
public var shape: Swift.String?
public var style: Swift.String?
public var alink: Swift.String?
public var width: Swift.String?
public var rules: Swift.String?
public var align: Swift.String?
public var frame: Swift.String?
public var vlink: Swift.String?
public var deferr: Swift.String?
public var color: Swift.String?
public var media: Swift.String?
public var title: Swift.String?
public var scope: Swift.String?
public var classs: Swift.String?
public var manifest: Swift.String?
public var value: Swift.String?
public var clear: Swift.String?
public var start: Swift.String?
public var label: Swift.String?
public var action: Swift.String?
public var height: Swift.String?
public var method: Swift.String?
public var acceptt: Swift.String?
public var object: Swift.String?
public var scheme: Swift.String?
public var coords: Swift.String?
public var usemap: Swift.String?
public var onblur: Swift.String?
public var nohref: Swift.String?
public var nowrap: Swift.String?
public var hspace: Swift.String?
public var border: Swift.String?
public var valign: Swift.String?
public var vspace: Swift.String?
public var onload: Swift.String?
public var target: Swift.String?
public var prompt: Swift.String?
public var onfocus: Swift.String?
public var enctype: Swift.String?
public var onclick: Swift.String?
public var ontouchstart: Swift.String?
public var onkeyup: Swift.String?
public var profile: Swift.String?
public var version: Swift.String?
public var onreset: Swift.String?
public var charset: Swift.String?
public var standby: Swift.String?
public var colspan: Swift.String?
public var charoff: Swift.String?
public var classid: Swift.String?
public var compact: Swift.String?
public var declare: Swift.String?
public var rowspan: Swift.String?
public var checked: Swift.String?
public var archive: Swift.String?
public var bgcolor: Swift.String?
public var content: Swift.String?
public var noshade: Swift.String?
public var summary: Swift.String?
public var headers: Swift.String?
public var onselect: Swift.String?
public var readonly: Swift.String?
public var tabindex: Swift.String?
public var onchange: Swift.String?
public var noresize: Swift.String?
public var disabled: Swift.String?
public var longdesc: Swift.String?
public var codebase: Swift.String?
public var language: Swift.String?
public var datetime: Swift.String?
public var selected: Swift.String?
public var hreflang: Swift.String?
public var onsubmit: Swift.String?
public var multiple: Swift.String?
public var onunload: Swift.String?
public var codetype: Swift.String?
public var scrolling: Swift.String?
public var onkeydown: Swift.String?
public var maxlength: Swift.String?
public var valuetype: Swift.String?
public var accesskey: Swift.String?
public var onmouseup: Swift.String?
public var autofocus: Swift.String?
public var onkeypress: Swift.String?
public var ondblclick: Swift.String?
public var onmouseout: Swift.String?
public var httpEquiv: Swift.String?
public var dataText: Swift.String?
public var background: Swift.String?
public var onmousemove: Swift.String?
public var onmouseover: Swift.String?
public var cellpadding: Swift.String?
public var onmousedown: Swift.String?
public var frameborder: Swift.String?
public var marginwidth: Swift.String?
public var cellspacing: Swift.String?
public var placeholder: Swift.String?
public var marginheight: Swift.String?
public var acceptCharset: Swift.String?
public var inner: Swift.String?
public func a(_ closure: () -> Swift.Void)
public func b(_ closure: () -> Swift.Void)
public func i(_ closure: () -> Swift.Void)
public func p(_ closure: () -> Swift.Void)
public func q(_ closure: () -> Swift.Void)
public func s(_ closure: () -> Swift.Void)
public func u(_ closure: () -> Swift.Void)
public func br(_ closure: () -> Swift.Void)
public func dd(_ closure: () -> Swift.Void)
public func dl(_ closure: () -> Swift.Void)
public func dt(_ closure: () -> Swift.Void)
public func em(_ closure: () -> Swift.Void)
public func hr(_ closure: () -> Swift.Void)
public func li(_ closure: () -> Swift.Void)
public func ol(_ closure: () -> Swift.Void)
public func rp(_ closure: () -> Swift.Void)
public func rt(_ closure: () -> Swift.Void)
public func td(_ closure: () -> Swift.Void)
public func th(_ closure: () -> Swift.Void)
public func tr(_ closure: () -> Swift.Void)
public func tt(_ closure: () -> Swift.Void)
public func ul(_ closure: () -> Swift.Void)
public func ul<T>(_ collection: T, _ closure: @escaping (T.Iterator.Element) -> Swift.Void) where T : Swift.Sequence
public func h1(_ closure: () -> Swift.Void)
public func h2(_ closure: () -> Swift.Void)
public func h3(_ closure: () -> Swift.Void)
public func h4(_ closure: () -> Swift.Void)
public func h5(_ closure: () -> Swift.Void)
public func h6(_ closure: () -> Swift.Void)
public func bdi(_ closure: () -> Swift.Void)
public func bdo(_ closure: () -> Swift.Void)
public func big(_ closure: () -> Swift.Void)
public func col(_ closure: () -> Swift.Void)
public func del(_ closure: () -> Swift.Void)
public func dfn(_ closure: () -> Swift.Void)
public func dir(_ closure: () -> Swift.Void)
public func div(_ closure: () -> Swift.Void)
public func img(_ closure: () -> Swift.Void)
public func ins(_ closure: () -> Swift.Void)
public func kbd(_ closure: () -> Swift.Void)
public func map(_ closure: () -> Swift.Void)
public func nav(_ closure: () -> Swift.Void)
public func pre(_ closure: () -> Swift.Void)
public func rtc(_ closure: () -> Swift.Void)
public func sub(_ closure: () -> Swift.Void)
public func sup(_ closure: () -> Swift.Void)
public func varr(_ closure: () -> Swift.Void)
public func wbr(_ closure: () -> Swift.Void)
public func xmp(_ closure: () -> Swift.Void)
public func abbr(_ closure: () -> Swift.Void)
public func area(_ closure: () -> Swift.Void)
public func base(_ closure: () -> Swift.Void)
public func body(_ closure: () -> Swift.Void)
public func cite(_ closure: () -> Swift.Void)
public func code(_ closure: () -> Swift.Void)
public func data(_ closure: () -> Swift.Void)
public func font(_ closure: () -> Swift.Void)
public func form(_ closure: () -> Swift.Void)
public func head(_ closure: () -> Swift.Void)
public func html(_ closure: () -> Swift.Void)
public func link(_ closure: () -> Swift.Void)
public func main(_ closure: () -> Swift.Void)
public func mark(_ closure: () -> Swift.Void)
public func menu(_ closure: () -> Swift.Void)
public func meta(_ closure: () -> Swift.Void)
public func nobr(_ closure: () -> Swift.Void)
public func ruby(_ closure: () -> Swift.Void)
public func samp(_ closure: () -> Swift.Void)
public func span(_ closure: () -> Swift.Void)
public func time(_ closure: () -> Swift.Void)
public func aside(_ closure: () -> Swift.Void)
public func audio(_ closure: () -> Swift.Void)
public func blink(_ closure: () -> Swift.Void)
public func embed(_ closure: () -> Swift.Void)
public func frame(_ closure: () -> Swift.Void)
public func image(_ closure: () -> Swift.Void)
public func input(_ closure: () -> Swift.Void)
public func label(_ closure: () -> Swift.Void)
public func meter(_ closure: () -> Swift.Void)
public func param(_ closure: () -> Swift.Void)
public func small(_ closure: () -> Swift.Void)
public func style(_ closure: () -> Swift.Void)
public func table(_ closure: () -> Swift.Void)
public func table<T>(_ collection: T, closure: @escaping (T.Iterator.Element) -> Swift.Void) where T : Swift.Sequence
public func tbody(_ closure: () -> Swift.Void)
public func tbody<T>(_ collection: T, closure: @escaping (T.Iterator.Element) -> Swift.Void) where T : Swift.Sequence
public func tfoot(_ closure: () -> Swift.Void)
public func thead(_ closure: () -> Swift.Void)
public func title(_ closure: () -> Swift.Void)
public func track(_ closure: () -> Swift.Void)
public func video(_ closure: () -> Swift.Void)
public func applet(_ closure: () -> Swift.Void)
public func button(_ closure: () -> Swift.Void)
public func canvas(_ closure: () -> Swift.Void)
public func center(_ closure: () -> Swift.Void)
public func dialog(_ closure: () -> Swift.Void)
public func figure(_ closure: () -> Swift.Void)
public func footer(_ closure: () -> Swift.Void)
public func header(_ closure: () -> Swift.Void)
public func hgroup(_ closure: () -> Swift.Void)
public func iframe(_ closure: () -> Swift.Void)
public func keygen(_ closure: () -> Swift.Void)
public func legend(_ closure: () -> Swift.Void)
public func object(_ closure: () -> Swift.Void)
public func option(_ closure: () -> Swift.Void)
public func output(_ closure: () -> Swift.Void)
public func script(_ closure: () -> Swift.Void)
public func select(_ closure: () -> Swift.Void)
public func shadow(_ closure: () -> Swift.Void)
public func source(_ closure: () -> Swift.Void)
public func spacer(_ closure: () -> Swift.Void)
public func strike(_ closure: () -> Swift.Void)
public func strong(_ closure: () -> Swift.Void)
public func acronym(_ closure: () -> Swift.Void)
public func address(_ closure: () -> Swift.Void)
public func article(_ closure: () -> Swift.Void)
public func bgsound(_ closure: () -> Swift.Void)
public func caption(_ closure: () -> Swift.Void)
public func command(_ closure: () -> Swift.Void)
public func content(_ closure: () -> Swift.Void)
public func details(_ closure: () -> Swift.Void)
public func elementt(_ closure: () -> Swift.Void)
public func isindex(_ closure: () -> Swift.Void)
public func listing(_ closure: () -> Swift.Void)
public func marquee(_ closure: () -> Swift.Void)
public func noembed(_ closure: () -> Swift.Void)
public func picture(_ closure: () -> Swift.Void)
public func section(_ closure: () -> Swift.Void)
public func summary(_ closure: () -> Swift.Void)
public func basefont(_ closure: () -> Swift.Void)
public func colgroup(_ closure: () -> Swift.Void)
public func datalist(_ closure: () -> Swift.Void)
public func fieldset(_ closure: () -> Swift.Void)
public func frameset(_ closure: () -> Swift.Void)
public func menuitem(_ closure: () -> Swift.Void)
public func multicol(_ closure: () -> Swift.Void)
public func noframes(_ closure: () -> Swift.Void)
public func noscript(_ closure: () -> Swift.Void)
public func optgroup(_ closure: () -> Swift.Void)
public func progress(_ closure: () -> Swift.Void)
public func template(_ closure: () -> Swift.Void)
public func textarea(_ closure: () -> Swift.Void)
public func plaintext(_ closure: () -> Swift.Void)
public func javascript(_ closure: () -> Swift.Void)
public func blockquote(_ closure: () -> Swift.Void)
public func figcaption(_ closure: () -> Swift.Void)
public func stylesheet(_ closure: () -> Swift.Void)
public func element(_ node: Swift.String, _ closure: () -> Swift.Void)
public func element(_ node: Swift.String, _ attrs: [Swift.String : Swift.String?] = [:], _ closure: () -> Swift.Void)
@_inheritsConvenienceInitializers open class HttpServer : EyesonSdk.HttpServerIO {
  public static let VERSION: Swift.String
  public init()
  public var DELETE: EyesonSdk.HttpServer.MethodRoute, PATCH: EyesonSdk.HttpServer.MethodRoute, HEAD: EyesonSdk.HttpServer.MethodRoute, POST: EyesonSdk.HttpServer.MethodRoute, GET: EyesonSdk.HttpServer.MethodRoute, PUT: EyesonSdk.HttpServer.MethodRoute
  public var delete: EyesonSdk.HttpServer.MethodRoute, patch: EyesonSdk.HttpServer.MethodRoute, head: EyesonSdk.HttpServer.MethodRoute, post: EyesonSdk.HttpServer.MethodRoute, get: EyesonSdk.HttpServer.MethodRoute, put: EyesonSdk.HttpServer.MethodRoute
  public subscript(path: Swift.String) -> ((EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)? {
    get
    set
  }
  public var routes: [Swift.String] {
    get
  }
  public var notFoundHandler: ((EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)?
  public var middleware: [(EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse?]
  override open func dispatch(_ request: EyesonSdk.HttpRequest) -> ([Swift.String : Swift.String], (EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)
  public struct MethodRoute {
    public let method: Swift.String
    public let router: EyesonSdk.HttpRouter
    public subscript(path: Swift.String) -> ((EyesonSdk.HttpRequest) -> EyesonSdk.HttpResponse)? {
      get
      set
    }
  }
  @objc deinit
}
public struct SHA1 {
  public static func hash(_ input: [Swift.UInt8]) -> [Swift.UInt8]
}
extension Swift.String {
  public func sha1() -> [Swift.UInt8]
  public func sha1() -> Swift.String
}
extension EyesonSdk.Eyeson.Device : Swift.Equatable {}
extension EyesonSdk.Eyeson.Device : Swift.Hashable {}
extension EyesonSdk.Eyeson.TerminateReason : Swift.Equatable {}
extension EyesonSdk.Eyeson.TerminateReason : Swift.Hashable {}
extension EyesonSdk.Eyeson.TerminateReason : Swift.RawRepresentable {}
extension EyesonSdk.Eyeson.Event.Stats.Status : Swift.Equatable {}
extension EyesonSdk.Eyeson.Event.Stats.Status : Swift.Hashable {}
extension EyesonSdk.Eyeson.Event.Stats.Status : Swift.RawRepresentable {}
extension EyesonSdk.SwiftyJSONError : Swift.Equatable {}
extension EyesonSdk.SwiftyJSONError : Swift.Hashable {}
extension EyesonSdk.SwiftyJSONError : Swift.RawRepresentable {}
extension EyesonSdk.`Type` : Swift.Equatable {}
extension EyesonSdk.`Type` : Swift.Hashable {}
extension EyesonSdk.`Type` : Swift.RawRepresentable {}
extension EyesonSdk.writingOptionsKeys : Swift.Equatable {}
extension EyesonSdk.writingOptionsKeys : Swift.Hashable {}
extension EyesonSdk.HttpServerIO.HttpServerIOState : Swift.Equatable {}
extension EyesonSdk.HttpServerIO.HttpServerIOState : Swift.Hashable {}
extension EyesonSdk.HttpServerIO.HttpServerIOState : Swift.RawRepresentable {}
extension EyesonSdk.Environment : Swift.Equatable {}
extension EyesonSdk.Environment : Swift.Hashable {}
extension EyesonSdk.Environment : Swift.RawRepresentable {}
extension EyesonSdk.CloseCode : Swift.Equatable {}
extension EyesonSdk.CloseCode : Swift.Hashable {}
extension EyesonSdk.CloseCode : Swift.RawRepresentable {}
extension EyesonSdk.FrameOpCode : Swift.Equatable {}
extension EyesonSdk.FrameOpCode : Swift.Hashable {}
extension EyesonSdk.FrameOpCode : Swift.RawRepresentable {}
extension EyesonSdk.ErrorType : Swift.Equatable {}
extension EyesonSdk.ErrorType : Swift.Hashable {}
extension EyesonSdk.WebSocketSession.OpCode : Swift.Equatable {}
extension EyesonSdk.WebSocketSession.OpCode : Swift.Hashable {}
extension EyesonSdk.WebSocketSession.OpCode : Swift.RawRepresentable {}
extension EyesonSdk.WebSocketSession.Control : Swift.Equatable {}
extension EyesonSdk.WebSocketSession.Control : Swift.Hashable {}
extension EyesonSdk.FoundationSecurityError : Swift.Equatable {}
extension EyesonSdk.FoundationSecurityError : Swift.Hashable {}
extension EyesonSdk.SerializationError : Swift.Equatable {}
extension EyesonSdk.SerializationError : Swift.Hashable {}
extension EyesonSdk.SecurityErrorCode : Swift.Equatable {}
extension EyesonSdk.SecurityErrorCode : Swift.Hashable {}
extension EyesonSdk.SecurityErrorCode : Swift.RawRepresentable {}
extension EyesonSdk.FoundationTransportError : Swift.Equatable {}
extension EyesonSdk.FoundationTransportError : Swift.Hashable {}
extension EyesonSdk.TCPTransportError : Swift.Equatable {}
extension EyesonSdk.TCPTransportError : Swift.Hashable {}
